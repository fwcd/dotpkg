#!/usr/bin/env python3

# Generates Python dataclasses from the JSON schemas.

from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Optional

import re
import json

ROOT = Path(__file__).resolve().parent.parent

@dataclass
class Type:
    raw: str
    is_dataclass: bool = False

@dataclass
class Field:
    name: str
    original_name: str
    type: Type
    description: Optional[str] = None

@dataclass
class Parameter:
    name: str
    type: Optional[Type] = None

@dataclass
class Function:
    decorators: list[str]
    name: str
    parameters: list[Parameter]
    return_type: Type
    body: list[str]

@dataclass
class Dataclass:
    name: str
    description: Optional[str] = None
    fields: list[Field] = field(default_factory=list)
    methods: list[Function] = field(default_factory=list)

@dataclass
class Output:
    imports: set[str] = field(default_factory=set)
    dataclasses: list[Dataclass] = field(default_factory=lambda: [])

def from_camel_case(raw: str) -> list[str]:
    return [c.lower() for c in re.split(r'(?<=[a-z])(?=[A-Z])', raw)]

def to_snake_case(components: list[str]) -> str:
    return '_'.join(components)

def indent(lines: list[str]) -> list[str]:
    return [f'    {l}' for l in lines]

def format_type(type: Type) -> str:
    return type.raw

def format_field(field: Field) -> list[str]:
    return [
        f'{field.name}: {format_type(field.type)}',
        *([f"'''{field.description}'''"] if field.description else []),
    ]

def format_parameter(parameter: Parameter) -> str:
    return f'{parameter.name}: {format_type(parameter.type)}' if parameter.type else parameter.name

def format_function(function: Function) -> list[str]:
    return [
        *function.decorators,
        f"def {function.name}({', '.join(map(format_parameter, function.parameters))}) -> {format_type(function.return_type)}:",
        *indent(function.body),
    ]

def format_dataclass(dataclass: Dataclass) -> list[str]:
    return [
        '@dataclass',
        f'class {dataclass.name}:',
        *indent([
            *([f"'''{dataclass.description}'''", ''] if dataclass.description else []),
            *[l for f in dataclass.fields for l in [*format_field(f), '']],
            *[l for f in dataclass.methods for l in [*format_function(f), '']],
        ]),
    ]

def translate_schema(name: str, value: dict[str, Any], output: Output) -> Type:
    match value['type']:
        case 'string':
            return Type('str')
        case 'boolean':
            return Type('bool')
        case 'integer':
            return Type('int')
        case 'number':
            return Type('float')
        case 'array':
            return translate_schema(
                name=name,
                value=value['items'],
                output=output,
            )
        case 'object':
            if 'properties' in value:
                fields = [
                    Field(
                        name=to_snake_case(from_camel_case(key)),
                        original_name=key,
                        type=translate_schema(
                            name=key.capitalize(),
                            value=prop,
                            output=output,
                        ),
                        description=prop.get('description'),
                    )
                    for key, prop in value['properties'].items()
                ]
                output.dataclasses.append(Dataclass(
                    name=name,
                    description=value.get('description'),
                    fields=fields,
                ))
                return Type(raw=name, is_dataclass=True)
            elif 'additionalProperties' in value:
                t = translate_schema(
                    name=name,
                    value=value['additionalProperties'],
                    output=output
                )
                return Type(f'dict[str, {format_type(t)}]')
            else:
                output.imports.add('from typing import Any')
                return Type('dict[str, Any]')
        case t:
            raise ValueError(f'Unknown type {t}')

def generate_from_dict_method(dataclass: Dataclass, output: Output) -> Function:
    def field_from_dict(f: Field) -> str:
        # TODO: Defaults
        s = f"d['{f.original_name}']"
        if f.type.is_dataclass:
            s = f'{format_type(f.type)}.from_dict({s})'
        return s

    output.imports.add('from typing import Any')
    return Function(
        decorators=['@staticmethod'],
        name='from_dict',
        parameters=[Parameter(name='d', type=Type('dict[str, Any]'))],
        return_type=Type(dataclass.name, is_dataclass=True),
        body=[
            f'return {dataclass.name}(',
            *indent([f"{f.name}={field_from_dict(f)}," for f in dataclass.fields]),
            f')',
        ],
    )

def generate_to_dict_method(dataclass: Dataclass, output: Output) -> Function:
    def field_to_dict(f: Field) -> str:
        # TODO: Defaults
        s = f'self.{f.name}'
        if f.type.is_dataclass:
            s += '.to_dict()'
        return s

    output.imports.add('from typing import Any')
    return Function(
        decorators=[],
        name='to_dict',
        parameters=[Parameter(name='self')],
        return_type=Type('dict[str, Any]'),
        body=[
            'return {',
            *indent([f"'{f.original_name}': {field_to_dict(f)}," for f in dataclass.fields]),
            '}',
        ],
    )
    pass

def main():
    for name in ['dotpkg', 'installs']:
        output = Output()

        with open(ROOT / 'schemas' / f'{name}.schema.json', 'r') as f:
            raw = json.load(f)
            translate_schema(
                name=f'{name.capitalize()}Manifest',
                value=raw,
                output=output
            )
        
        if output.dataclasses:
            output.imports.add('from __future__ import annotations')
            output.imports.add('from dataclasses import dataclass')
        
        for dataclass in output.dataclasses:
            dataclass.methods.append(generate_from_dict_method(dataclass, output))
            dataclass.methods.append(generate_to_dict_method(dataclass, output))
        
        with open(ROOT / 'dotpkg' / 'manifest' / f'{name}.py', 'w') as f:
            raw = '\n\n'.join([
                '\n'.join(sorted(output.imports)),
                *('\n'.join(format_dataclass(d)) for d in output.dataclasses),
                '',
            ])
            f.write(raw)
            

if __name__ == '__main__':
    main()
